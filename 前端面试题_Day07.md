# JavaScript

## 1. 执行栈与事件队列

当我们调用一个方法的时候，js会生成一个与这个方法对应的**执行环境**（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。

 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为**执行栈**。

当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

以上的过程说的都是**同步代码**的执行。

<hr>

那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——**事件队列**（Task Queue）。

js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。**被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。**如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

## 2. 运算符及优先级

|      |                                                     |
| ---- | --------------------------------------------------- |
|      |                                                     |
|      |                                                     |
|      |                                                     |
|      |                                                     |
| &    | 位运算符                                            |
| +    | 加法；字符串拼接。如'10'+3会得到'103'；隐式类型转换 |
| -    | 减法。如'103'-'1'会得到102                          |
| ,    |                                                     |



## 3. call, apply, bind



## 4.正则表达式



## 5. var声明变量的提升

- 变量和函数的声明提升，但赋值不会提升
- 函数提升优先级高于变量提升

```javascript
var foo=function(x,y){
    return x-y;
}
function foo(x,y){
    return x+y;
}
var num=foo(1,2);
console.log(num);//结果是-1
// ----------------------原因在于上述代码等同于-----------------------
// 1.函数声明提升
function foo(x,y){
    return x+y
}
// 2.变量声明提升
var foo;
var num;
// 3.变量赋值不提升
foo = function(x,y){
    return x-y
}
num = foo(1,2)
console.log(num)
```



## 6. 继承

**构造函数继承**是每次继承都会把父类的所有属性方法全部拷贝一份，而对于公用的方法重复拷贝会浪费内存
**原型链继承**所有对象都公用一份原型属性和方法，对一个类的修改回影响的其他类
**组合继承**是结合两种继承方式，用**构造函数方式继承属性，原型链方式继承方法**

## 7. 对象调用

- 调用对象未声明的属性会undefined
- 调用对象已声明但未赋值的属性会报错
- 调用未声明的变量会报错
- 调用已声明但未赋值的变量会undefined

## 8. 微任务、宏任务



## 9. 冒泡

不能被冒泡的9个事件：

- load和unload 
- mouseenter和mouseleave 
- blur和focus 
- error 
- resize和abort

从3个角度说可分为ui事件、鼠标移入移出事件、聚焦和失焦事件

## 10. typeof

| 类型      | 结果      |
| --------- | --------- |
| Number    | number    |
| NaN       | number    |
| String    | string    |
| Object    | object    |
| null      | object    |
| Array     | object    |
| Function  | function  |
| Undefined | undefined |
| Boolean   | boolean   |
| Symbol    | symbol    |

## 11. 生成器函数



## 12. 闭包

- 闭包是指有权访问另一个函数作用域中变量的函数
- 函数内再嵌套函数，返回到外部形成闭包
- 内部函数可以引用外层的参数和变量
- 参数和变量不会被垃圾回收机制回收

## 13. instanceof



## 14. this

- 在不手动改变this指向的前提下，this总是指向函数的直接调用对象
- 如果有new关键字，this指向new出来的那个对象
- IE中attachEvent中的this总是指向全局对象window